#!/bin/sh

set -e

/bin/postMessage "Starting Disk Wipe..."

for x in $(cat /proc/cmdline)
do
  case $x in
    mode=*)
      diskwipe_mode=${x#mode=}
      ;;
  esac
done

if [ "x$diskwipe_mode" == "x" ]
then
  eval $( /bin/setEnv diskwipe_mode )
fi

if [ "x$diskwipe_mode" == "x" ]
then
  diskwipe_mode="mbr"
fi

# the -e suppresses the wild card expression if it dosen't match
wrk_list=`for i in /sys/block/[hs]d* /sys/block/nvme* ; do [ -e "$i" ] && echo $i | awk '{ split( $0, a, "/" ); print a[4] }'; done`
drive_list=""

for drive in $wrk_list;
do
  wipedrive -q --check --trim /dev/$drive && rc=0 || rc=$?
  if [ "$rc" -eq "0" ];
  then
    drive_list="$drive_list $drive:trim"
  else
    wipedrive -q --check /dev/$drive && rc=0 || rc=$?
    if [ "$rc" -eq "0" ];
    then
      drive_list="$drive_list $drive:wipedrive"
    else
      drive_list="$drive_list $drive:dd"
    fi
  fi
done

echo "Doing mode '$diskwipe_mode'"
echo "Doing Drives:"
echo $drive_list

case $diskwipe_mode in
  partition_tables)
    /partition_tables $drive_list && rc=0 || rc=$?
  ;;
  mbr)
    /mbr $drive_list && rc=0 || rc=$?
  ;;
  extnd_part_or_trim_all)
    /extnd_part_or_trim_all $drive_list && rc=0 || rc=$?
  ;;
  extended_partition_tables)
    /extended_partition_tables $drive_list && rc=0 || rc=$?
  ;;
  single_pass)
    /single_pass $drive_list && rc=0 || rc=$?
  ;;
  multi_pass)
    /multi_pass $drive_list && rc=0 || rc=$?
  ;;
  *)
    echo "Unknown wipe mode '$diskwipe_mode'"
    rc=1
  ;;
esac

if [ "$rc" -ne "0" ];
then
  /bin/signalAlert "Disk Wipe Failed."
  exit 10
fi

# TODO: need a better way to find items that are on the local drives
if [ -d /sys/firmware/efi ]
then
  /bin/postMessage "Cleaning up EFI Boot."
  for item in `efibootmgr | awk '/HD/ { gsub( /Boot|\*/, "", $1 ); print $1 }'`;
  do
    echo "Deleting EFI Boot Item $item"
    efibootmgr -q -B -b $item
  done
fi

/bin/postMessage "Disk Wipe Complete."
/bin/signalComplete

exit 0